#include "ccbot.h"

#include <QSettings>
#include <QApplication>
#include <QDir>
#include <QUrl>
#include <QJsonObject>
#include <QJsonArray>
#include <QJsonDocument>
#include <QDebug>
#include <QStandardPaths>

#include "misc.h"

CCBot::CCBot(Properties *params, QObject *parent) : CCBotEngine(parent),
    m_player(new QMediaPlayer)
{    
    m_params = params;

    loadSettings();

    initConnections();
    initTasks();
    initTimers();

    QString test = QString("test —Ç–µ—Å—Ç ") + QString::fromUtf8("\xF0\x9F\x98\x81");

    std::wstring wtest = test.toStdWString();
    for (size_t i = 0; i < wtest.length(); i++) {

        if(wtest.at(i) == 0x1F601)
            qDebug() << i << ":" << wtest.at(i) << ":" << QString::number(wtest.at(i), 16);
    }

    //m_params->setTestStr(test);
    //emit showChatMessage(test);
}

CCBot::~CCBot()
{
    delete m_player;
}

void CCBot::loadSettings()
{
    QSettings cfg;

    cfg.beginGroup("Window");
    m_params->setWindowX(cfg.value("X", 0).toInt());
    m_params->setWindowY(cfg.value("Y", 0).toInt());
    m_params->setWindowHeight(cfg.value("HEIGHT", 900).toInt());
    m_params->setWindowWidth(cfg.value("WIDTH", 1000).toInt());
    cfg.endGroup();

    cfg.beginGroup("View");
    m_params->setFontNameForChat(cfg.value("FontNameForChat", "Noto Sans").toString());
    m_params->setFontPointSizeForChat(
                cfg.value("FontPointSizeForChat", 12.0).toFloat());
    m_params->setTextColorForChat(cfg.value("TextColorForChat", QColor("#bfc7d0")).value<QColor>());
    cfg.endGroup();

    cfg.beginGroup("Server");
    m_params->setMaxTimestampDiff(cfg.value("MaxTDiff", 5).toInt());
    m_params->setListenHost(cfg.value("Host", "127.0.0.1").toString());
    m_params->setListenPort(cfg.value("Port", 3000U).toUInt());
    cfg.endGroup();

    cfg.beginGroup("SpeechKit");
    m_params->setSpeechkitFolderId(cfg.value("FolderID", "").toString());
    m_params->setSpeechkitOAuthToken(cfg.value("OAuthToken", "").toString());
    m_params->setSpeechkitHost(
                cfg.value("Host", defaultSpeechkitHost).toString());
    m_params->setSpeechkitGetIamTokenHost(
                cfg.value("IamTokenHost",
                          defaultSpeechkitGetIamTokenHost).toString());
    m_params->setSpeechkitLang(
                cfg.value("Lang", defaultSpeechkitLang).toString());
    m_params->setSpeechkitFormat(
                cfg.value("Format", defaultSpeechkitFormat).toString());
    m_params->setSpeechkitVoice(
                cfg.value("Voice", defaultSpeechkitVoice).toString());
    m_params->setSpeechkitEmotion(
                cfg.value("Emotion", defaultSpeechkitEmotion).toString());
    m_params->setSpeechkitSpeed(
                cfg.value("Speed", defaultSpeechkitSpeed).toString());
    m_params->setSpeechkitSampleRateHertz(
                cfg.value("SampleRateHertz",
                          defaultSpeechkitSampleRateHertz).toString());
    cfg.endGroup();
}

void CCBot::saveSettings()
{
    QSettings cfg;

    cfg.beginGroup("Window");
    cfg.setValue("X", m_params->windowX());
    cfg.setValue("Y", m_params->windowY());
    cfg.setValue("HEIGHT", m_params->windowHeight());
    cfg.setValue("WIDTH", m_params->windowWidth());
    cfg.endGroup();

    cfg.beginGroup("View");
    cfg.setValue("FontNameForChat", m_params->fontNameForChat());
    cfg.setValue("FontPointSizeForChat", m_params->fontPointSizeForChat());
    cfg.setValue("TextColorForChat", m_params->textColorForChat());
    cfg.endGroup();

    cfg.beginGroup("Server");
    cfg.setValue("MaxTDiff", m_params->maxTimestampDiff());
    cfg.setValue("Host", m_params->listenHost());
    cfg.setValue("Port", m_params->listenPort());
    cfg.endGroup();

    cfg.beginGroup("SpeechKit");
    cfg.setValue("FolderID", m_params->speechkitFolderId());
    cfg.setValue("OAuthToken", m_params->speechkitOAuthToken());
    cfg.setValue("Host", m_params->speechkitHost());
    cfg.setValue("IamTokenHost", m_params->speechkitGetIamTokenHost());
    cfg.setValue("Lang", m_params->speechkitLang());
    cfg.setValue("Format", m_params->speechkitFormat());
    cfg.setValue("Voice", m_params->speechkitVoice());
    cfg.setValue("Emotion", m_params->speechkitEmotion());
    cfg.setValue("Speed", m_params->speechkitSpeed());
    cfg.setValue("SampleRateHertz", m_params->speechkitSampleRateHertz());
    cfg.endGroup();
    //...
}

void CCBot::initTimers()
{
    //
}

void CCBot::initConnections()
{
    // —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ: –∑–∞–≤–µ—Ä—à–µ–Ω–∏–µ –ø—Ä–æ–≥—Ä–∞–º–º—ã
    connect(this, &CCBotEngine::signQuit, [=]() {
        QApplication::quit();
    });

    connect(m_player,
            &QMediaPlayer::stateChanged,
            [this](QMediaPlayer::State state)
    {
        if (state == QMediaPlayer::StoppedState) {
            emit completePlayFile();
        }
    });

    connect(m_params, &Properties::listenClientsChanged, [this]() {
        if (m_params->listenClients() == true) {
            openDB();
        } else {
            closeDB();
        }
    });
}

void CCBot::initTasks()
{
    m_pCore->registerTask(CCBotTaskEnums::MergeChat,
                          [this](
                          QString streamId,
                          QString messagesJsonStr,
                          bool loading) -> TaskResult
    {
        TaskResult result;
        QString errInfo = "";
        int state = 0;

        QMetaObject::invokeMethod(
                    this,
                    "insertNewMessagesInTable",
                    Qt::BlockingQueuedConnection,
                    Q_RETURN_ARG(int, state),
                    Q_ARG(QString, streamId),
                    Q_ARG(QByteArray, messagesJsonStr.toUtf8()),
                    Q_ARG(bool, !loading),
                    Q_ARG(QString*, &errInfo)
                    );

        if(state != CCBotErrEnums::Ok) {
            return TaskResult(state, errInfo);
        }
        return TaskResult();
    });

    m_pCore->registerTask(CCBotTaskEnums::VoiceLoad,
                          [this](QString text) -> TaskResult {
        TaskResult result;
        QNetworkAccessManager *manager = new QNetworkAccessManager();

        // 1. –ü—Ä–æ–≤–µ—Ä–∫–∞ —á—Ç–æ —Ç–æ–∫–µ–Ω –∏—Å—Ç–µ–∫
        bool tokenExpiry =
                QDateTime::currentDateTime() >= m_params->speechkitIamTokenExpiryDate();
        if (tokenExpiry) {
            // 1.1 –ï—Å–ª–∏ —Ç–æ–∫–µ–Ω —É–∂–µ –Ω–µ –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª–µ–Ω —Ç–æ:
            // –ø–æ–ª—É—á–∞–µ–º –Ω–æ–≤—ã–π –∏ –æ–±–Ω–æ–≤–ª—è–µ–º –¥–∞—Ç—É

            // * —Ñ–æ—Ä–º–∏—Ä—É–µ–º –∑–∞–ø—Ä–æ—Å
            QNetworkRequest requestGetIamToken;
            requestGetIamToken.setUrl(
                        QUrl(m_params->speechkitGetIamTokenHost()));
            requestGetIamToken.setHeader(
                        QNetworkRequest::ContentTypeHeader,
                        "application/json");
            QJsonObject obj;
            obj["yandexPassportOauthToken"] = m_params->speechkitOAuthToken();
            QJsonDocument doc(obj);
            QByteArray data = doc.toJson();

            // * –¥–µ–ª–∞–µ–º –∑–∞–ø—Ä–æ—Å
            manager->setTransferTimeout(constTimeoutGetIamToken);
            QNetworkReply *reply = manager->post(requestGetIamToken, data);
            QNetworkReply::NetworkError errType = QNetworkReply::NoError;
            QList<QSslError> errorsSsl;

            connect(reply,
                    &QNetworkReply::finished,
                    this,
                    [&]() {
                QByteArray response = reply->readAll();
                QJsonObject responseObj =
                        QJsonDocument::fromJson(response).object();
                m_params->setSpeechkitIamToken(
                            responseObj.value("iamToken").toString());
                m_params->setSpeechkitIamTokenExpiryDate(
                            QDateTime::fromString(
                                responseObj.value("expiresAt").toString(),
                                Qt::ISODateWithMs)
                            );
                //qDebug() << "IamToken: " << m_params->speechkitIamToken();
                //qDebug() << "expiresAt: " << m_params->speechkitIamTokenExpiryDate().toString();
                emit completeRequestGetIamToken();
            });

            connect(reply,
                    &QNetworkReply::errorOccurred,
                    this,
                    [&](QNetworkReply::NetworkError error) {
                errType = error;
                //qDebug() << "err" << error;
                emit completeRequestGetIamToken();
            });

            connect(reply,
                    &QNetworkReply::sslErrors,
                    this,
                    [&](const QList<QSslError> &errors) {
                errorsSsl = errors;
                //qDebug() << "TEST_2";
                emit completeRequestGetIamToken();
            });

            bool timeout = !waitSignal(this,
                                       &CCBot::completeRequestGetIamToken,
                                       constTimeoutGetIamToken + 500);
            reply->disconnect();

            if(timeout) {
                result = TaskResult(CCBotErrEnums::NetworkRequest,
                                    "Timeout request, not get iam-token!");
                delete manager;
                return result;
            }

            if(errType != QNetworkReply::NoError || !errorsSsl.isEmpty()) {
                QString mainInfo = QString("Error request (")
                        + QString::number(static_cast<int>(errType))
                        + "), ";
                QString secondInfo =
                        errorsSsl.isEmpty() ?
                            QString("no ssl errors") :
                            QString("%1 ssl errors").arg(errorsSsl.size());
                result = TaskResult(CCBotErrEnums::NetworkRequest,
                                    mainInfo + secondInfo);
                delete manager;
                return result;
            }
        }

        // 2. –ó–∞–ø—Ä–æ—Å –∑–≤—É–∫–æ–≤–æ–≥–æ —Ñ–∞–π–ª–∞ —Å —Å–µ—Ä–≤–µ—Ä–∞ –Ω–∞ —Ç–µ–∫—Å—Ç
        // –ø–æ–≤—Ç–æ—Ä–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –¥–∞—Ç—ã —Ç–æ–∫–µ–Ω–∞
        tokenExpiry = QDateTime::currentDateTime() >= m_params->speechkitIamTokenExpiryDate();
        if (!tokenExpiry) {
            QNetworkRequest requestGetAudio;
            QUrl url(m_params->speechkitHost());
            QStringList requestDataList;

            // * add header
            requestGetAudio.setHeader(QNetworkRequest::ContentTypeHeader,
                                      "application/x-www-form-urlencoded");
            requestGetAudio.setRawHeader("Authorization",
                                         QString("Bearer %1")
                                         .arg(m_params->speechkitIamToken())
                                         .toUtf8());
            // * add data
            requestDataList.append(QString("text=%1")
                                   .arg(text));
            requestDataList.append(QString("folderId=%1")
                                   .arg(m_params->speechkitFolderId()));
            if (!m_params->speechkitLang().isEmpty()) {
                requestDataList.append(QString("lang=%1")
                                       .arg(m_params->speechkitLang()));
            }
            if (!m_params->speechkitVoice().isEmpty()) {
                requestDataList.append(QString("voice=%1")
                                       .arg(m_params->speechkitVoice()));
            }
            if (!m_params->speechkitEmotion().isEmpty()) {
                requestDataList.append(QString("emotion=%1")
                                       .arg(m_params->speechkitEmotion()));
            }
            if (!m_params->speechkitSpeed().isEmpty()) {
                requestDataList.append(QString("speed=%1")
                                       .arg(m_params->speechkitSpeed()));
            }
            if (!m_params->speechkitFormat().isEmpty()) {
                requestDataList.append(QString("format=%1")
                                       .arg(m_params->speechkitFormat()));
            }
            if (!m_params->speechkitSampleRateHertz().isEmpty()) {
                requestDataList.append(
                            QString("sampleRateHertz=%1")
                            .arg(m_params->speechkitSampleRateHertz()));
            }
            QByteArray requestData = requestDataList.join("&").toUtf8();

            // * –∑–∞–ø—Ä–æ—Å
            // * –¥–µ–ª–∞–µ–º –∑–∞–ø—Ä–æ—Å
            manager->setTransferTimeout(constTimeoutGetAudio);
            requestGetAudio.setUrl(url);
            QNetworkReply *reply = manager->post(requestGetAudio, requestData);
            QNetworkReply::NetworkError errType = QNetworkReply::NoError;
            QList<QSslError> errorsSsl;
            connect(reply, &QNetworkReply::finished, this, [&reply,this]() {
                QByteArray response = reply->readAll();
                if (QJsonDocument::fromJson(response).isObject()) {
                    //qDebug() << "no_audio: " << response;
                } else {
                    //qDebug() << "with audio";
                    // —Å–æ—Ö—Ä–∞–Ω—è–µ–º —Ñ–∞–π–ª –Ω–∞ –¥–∏—Å–∫–µ
                    // –∏ –ø–µ—Ä–µ–¥–∞–µ–º –Ω–æ–≤–æ–π –∑–∞–¥–∞—á–∏ –∏–º—è —Ñ–∞–π–ª–∞
                    QTemporaryFile tmpfile;
                    if (tmpfile.open()) {
                        tmpfile.setAutoRemove(false);
                        QDataStream ostream(&tmpfile);
                        ostream.writeRawData(response, response.size());
                        tmpfile.close();
                        m_pCore->addTask(CCBotTaskEnums::VoiceSpeech,
                                         tmpfile.fileName());
                    }
                }
                emit completeRequestGetAudio();
            });
            connect(reply,
                    &QNetworkReply::errorOccurred,
                    this,
                    [&](QNetworkReply::NetworkError error) {
                errType = error;
                //qDebug() << "err" << error;
                emit completeRequestGetAudio();
            });
            connect(reply,
                    &QNetworkReply::sslErrors,
                    this,
                    [&](const QList<QSslError> &errors) {
                errorsSsl = errors;
                //qDebug() << "TEST_2";
                emit completeRequestGetAudio();
            });

            bool timeout = !waitSignal(this,
                                       &CCBot::completeRequestGetAudio,
                                       constTimeoutGetAudio + 500);
            reply->disconnect();

            if(timeout) {
                result =
                        TaskResult(CCBotErrEnums::NetworkRequest,
                                   "Timeout request, not get audio!");
                delete manager;
                return result;
            }
            if(errType != QNetworkReply::NoError ||
                    !errorsSsl.isEmpty())
            {
                QString mainInfo =
                        QString("Error request (")
                        + QString::number(static_cast<int>(errType))
                        + "), ";
                QString secondInfo =
                        errorsSsl.isEmpty() ?
                            QString("no ssl errors") :
                            QString("%1 ssl errors").arg(errorsSsl.size());
                result = TaskResult(CCBotErrEnums::NetworkRequest,
                                    mainInfo + secondInfo);
                delete manager;
                return result;
            }
        }
        // 3. –ó–∞–≤–µ—Ä—à–µ–Ω–∏–µ
        delete manager;
        return result;
    }, 1);

    m_pCore->registerTask(CCBotTaskEnums::VoiceSpeech,
                          [this](QString filename) -> TaskResult
    {
        TaskResult result;
        //qDebug() << "speek_filename: " << filename;
        QMetaObject::invokeMethod(this,
                                  "speechFile",
                                  Qt::BlockingQueuedConnection,
                                  Q_ARG(QString, filename)
                                  );
        // –æ—á–∏—Å—Ç–∫–∞
        QFile::remove(filename);
        return TaskResult();
    }, 2);
}

void CCBot::speechFile(QString filename)
{
    waitSignalAfterFunction(this,
                            &CCBot::completePlayFile,
                            [&filename, this]()
    {
        m_player->setMedia(QUrl::fromLocalFile(filename));
        m_player->setVolume(100);
        m_player->play();
    });
}

QString CCBot::generateErrMsg(int type, int errCode, QString info)
{
    Q_UNUSED(type)

    if(errCode == CCBotErrEnums::Ok)
        return "";
    if(errCode == CCBotErrEnums::NoInit)
        return QString("–ó–∞–¥–∞—á–∞ –Ω–µ –≤—ã–ø–æ–ª–Ω—è–ª–∞—Å—å, —Ä–µ–∑—É–ª—å—Ç–∞—Ç –Ω–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω.");
    if(errCode == CCBotErrEnums::ParseJson)
        return QString("–§–∞—Ç–∞–ª—å–Ω–∞—è –æ—à–∏–±–∫–∞, –Ω–µ —É–¥–∞–ª–æ—Å—å —Ä–∞—Å–ø–∞—Ä—Å–∏—Ç—å JSON-–¥–∞–Ω–Ω—ã–µ.");
    if(errCode == CCBotErrEnums::Sql)
        return QString("–û—à–∏–±–∫–∞ SQL: %1").arg(info);
    if(errCode == CCBotErrEnums::NetworkRequest)
        return QString("%1").arg(info);

    return QString("–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞, –Ω–µ—Ç –æ–ø–∏—Å–∞–Ω–∏—è.");
}

QString CCBot::modifyMsg(const QString &text)
{
    // init emotion power counters
    qint8 funnyPower = 0;       // (-) –≥—Ä—É—Å—Ç—å .. —Ä–∞–¥–æ—Å—Ç—å (+)
    qint8 godnessPower = 0;     // (-) –∑–ª–æ–±–∞ .. –¥–æ–±—Ä–æ—Ç–∞ (+)
    qint8 likingPower = 0;      // (-) –æ—Ç–≤—Ä–∞—â–µ–Ω–∏–µ .. —Å–∏–º–ø–∞—Ç–∏—è (+)
    qint8 sicklinessPower = 0;  // –±–æ–ª–µ–∑–Ω–µ–Ω–Ω—ã–π (+)
    qint8 nicelyPower = 0;      // (-) –Ω–µ–ø—Ä–∏—è—Ç–Ω–æ .. –ø—Ä–∏—è—Ç–Ω–æ (+)
    qint8 sleepyPower = 0;      // —Å–æ–Ω–Ω—ã–π (+)
    qint8 fearPower = 0;        // —Å—Ç—Ä–∞—Ö (+)
    qint8 amazePower = 0;       // —É–¥–∏–≤–ª–µ–Ω–∏–µ (+)
    qint8 laughPower = 0;       // —Ä–∂–∞—á (+)

    // set counters
    std::wstring studiedText = text.toStdWString();
    for (size_t i = 0; i < studiedText.length(); i++) {
        wchar_t symbol = studiedText.at(i);
        switch (symbol) {
        case 0x1F601: // üòÅ - grinning face with smiling eyes
            funnyPower += 1;
            amazePower += 1;
            laughPower += 1;
            break;
        case 0x1F602: // üòÇ - face with tears of joy
            laughPower += 2;
            break;
        case 0x1F603: // üòÉ - smiling face with open mouth
            funnyPower += 1;
            break;
        case 0x1F604: // üòÑ - smiling face with open mouth and smiling eyes
            funnyPower += 2;
            break;
        case 0x1F605: // üòÖ - smiling face with open mouth and cold sweat
            funnyPower += 1;
            amazePower += 1;
            fearPower += 1;
            break;
        case 0x1F606: // üòÜ - smiling face with open mouth and tightly-closed eyes
            funnyPower += 3;
            laughPower += 2;
            break;
        case 0x1F609: // üòâ - winking face
            likingPower += 1;
            break;
        case 0x1F60A: // üòä - smiling face with smiling eyes
            funnyPower += 4;
            nicelyPower += 2;
            break;
        case 0x1F60B: // üòã - face savouring delicious food
            funnyPower += 2;
            nicelyPower += 1;
            break;
        case 0x1F60C: // üòå - relieved face
            fearPower = fearPower > 0 ? --fearPower : 0;
            break;
        case 0x1F60D: // üòç - smiling face with heart-shaped eyes
            likingPower += 4;
            break;
        case 0x1F60F: // üòè - smirking face
            likingPower += 1;
            break;
        case 0x1F612: // üòí - unamused face
            funnyPower -= 1;
            break;
        case 0x1F613: // üòì - face with cold sweat
            funnyPower -= 2;
            fearPower += 1;
            break;
        case 0x1F614: // üòî - pensive face
            funnyPower -= 1;
            break;
        case 0x1F616: // üòñ - confounded face
            funnyPower -= 2;
            break;
        case 0x1F618: // üòò - face throwing a kiss
            likingPower += 3;
            break;
        case 0x1F61A: // üòö - kissing face with closed eyes
            likingPower += 2;
            break;
        case 0x1F61C: // üòú - face with stuck-out tongue and winking eye
            likingPower += 1;
            break;
        default:
            break;
        }
    }

    return "";
}

//QString CCBot::clearUselessSymbols(const QString &text)
//{
//    QString result = text;

//    for (auto ch : result) {
//        if (ch == L'üòÇ') {
//            qDebug() << "ch:" << ch;
//        }
//    }

//    return result;
//}

bool CCBot::readMessagesFromJsonStr(QByteArray jsonData,
                                    QList<MessageData> &msgList,
                                    QString *errInfo)
{
    QJsonDocument jsonDoc;
    QJsonParseError parseError;

    jsonDoc = QJsonDocument::fromJson(jsonData, &parseError);
    if (parseError.error != QJsonParseError::NoError) {
        QString info = QString("Parse error at %1:%2")
                .arg(parseError.offset)
                .arg(parseError.errorString());
        //qDebug() << info;
        if (errInfo) {
            *errInfo = info;
        }
        return false;
    }

    QJsonArray jsonArr = jsonDoc.array();

    for (int i = 0; i < jsonArr.size(); i++) {
        MessageData msg;
        QJsonObject obj = jsonArr.at(i).toObject();
        msg.id = 0;
        msg.type = obj["type"].toInt();
        msg.sender = obj["sender"].toString();
        msg.nik_color = obj["nik_color"].toString();
        msg.msg = obj["msg"].toString();
        msg.pay = static_cast<float>(obj["pay"].toDouble());
        msg.flagIsNewMsg = true;
        msgList.append(msg);
    }

    return true;
}

bool CCBot::openDB()
{
    QString path =
            QStandardPaths::writableLocation(QStandardPaths::AppDataLocation);

//    qDebug() << path;

    if (path.isEmpty()) {
        qDebug() << "Cannot determine settings storage location";
        path = QDir::homePath() + QDir::separator() + ".ccbot";
    }

    QDir d{path};

    if (!d.exists()) {
        if (!d.mkpath(d.absolutePath())) {
            //qDebug() << QString("Cannot create path: %1").arg(d.absolutePath());
            return false;
        }
    }

    QString file_path = path + QDir::separator() + constNameBaseStr;

    if (QSqlDatabase::contains(QSqlDatabase::defaultConnection)) {
        m_db = QSqlDatabase::database();
    } else {
        m_db = QSqlDatabase::addDatabase("QSQLITE");
    }
    m_db.setDatabaseName(file_path);
    if (!m_db.open()) {
        qDebug() << "Error, missing database or opened from another program!";
        return false;
    }

    emit baseOpenned(true);

    return true;
}

void CCBot::closeDB()
{
    m_db.close();
    emit baseOpenned(false);
}

bool CCBot::createTableDB(QString streamId)
{
    QSqlQuery qry;

    const QString values =  "id INTEGER PRIMARY KEY AUTOINCREMENT, "
                            "type INTEGER NOT NULL, "
                            "sender TEXT, "
                            "nik_color TEXT, "
                            "msg TEXT, "
                            "pay REAL, "
                            "timestamp DATETIME";
    const QString sql = QString("CREATE TABLE IF NOT EXISTS 't_%1' (%2)")
            .arg(streamId, values);

    bool state = qry.exec(sql);

    return state;
}

bool CCBot::existsTableDB(QString streamId)
{
    QString tableName = "t_" + streamId;
    bool state = m_db.tables().contains(tableName);

    return state;
}

bool CCBot::selectMsgsFromTableDB(QString streamId,
                                  QList<MessageData> &msgList,
                                  int limit)
{
    QSqlQuery qry;
    QString sql;

    if(limit > 0) {
        sql = QString("SELECT * FROM ( "
                    "SELECT * FROM t_%1 ORDER BY id DESC LIMIT %2) "
                    "ORDER BY id ASC;")
                .arg(streamId).arg(limit);
    } else {
        sql = QString("SELECT * FROM t_%1 ORDER BY id ASC;").arg(streamId);
    }

    bool state = qry.exec(sql);

    if(state) {
        while(qry.next()) {
            MessageData msg;
            msg.id = qry.value("id").toULongLong();
            msg.type = qry.value("type").toInt();
            msg.sender = qry.value("sender").toString();
            msg.nik_color = qry.value("nik_color").toString();
            msg.msg = qry.value("msg").toString();
            msg.pay = qry.value("pay").toFloat();
            msg.timestamp = qry.value("timestamp").toDateTime();
            msgList.append(msg);
        }
    }

    return state;
}

bool CCBot::appendMsgIntoTableDB(QString streamId, QList<MessageData> &msgList)
{
    if (msgList.isEmpty()) {
        return true;
    }

    QDateTime timestamp = QDateTime::currentDateTime();

    for (int i = 0; i < msgList.size(); i++) {
        QSqlQuery qry;
        MessageData msg = msgList.at(i);
        msgList[i].timestamp = timestamp;
        QString sql = QString("INSERT INTO t_%1 (type, sender, nik_color, msg, pay, timestamp) VALUES (:type, :sender, :nik_color, :msg, :pay, :timestamp);").arg(streamId);
        qry.prepare(sql);
        qry.bindValue(":type", msg.type);
        qry.bindValue(":sender", msg.sender);
        qry.bindValue(":nik_color", msg.type == 1 ? "#fff200" : msg.nik_color);
        qry.bindValue(":msg", msg.msg);
        qry.bindValue(":pay", msg.pay);
        qry.bindValue(":timestamp", timestamp.toString("yyyy-MM-dd hh:mm:ss"));
        qry.exec();
    }

    return false;
}

int CCBot::insertNewMessagesInTable(QString streamId, QByteArray jsonData, bool merge, QString *errInfo)
{
    QList<MessageData> rowsFromDB;
    QList<MessageData> rowsFromServer;
    QList<MessageData> rowsForInsert;

    bool tableNotExist = false;
    bool state = false;

    // 0. –£–ø–∞–∫–æ–≤–∫–∞ –¥–∞–Ω–Ω—ã—Ö —Å CrazyCash
    state = readMessagesFromJsonStr(jsonData, rowsFromServer, errInfo);
    if(!state) {
        return CCBotErrEnums::ParseJson;
    }

    // 1. –ü—Ä–æ–≤–µ—Ä–∫–∞ —á—Ç–æ —Ç–∞–±–ª–∏—Ü–∞ –µ—Å—Ç—å, –∏–Ω–∞—á–µ —Å–æ–∑–¥–∞—Ç—å –µ–µ
    if (!existsTableDB(streamId)) {
        tableNotExist = true;
        if (!createTableDB(streamId)) {
            if (errInfo) {
                *errInfo = m_db.lastError().text();
            }
            return CCBotErrEnums::Sql;
        }
    }

    // Fix remove type 4
    int removeCount = 0;
    for (int i = 0; i < rowsFromServer.size(); i++) {
        if (rowsFromServer.at(i).type == 4) {
            rowsFromServer.removeAt(i--);
            ++removeCount;
        }
    }

    // 2. –ó–∞–ø—Ä–æ—Å 100 —Å–æ–æ–±—â–µ–Ω–∏–π —Å —Ç–∞–±–ª–∏—Ü—ã
    if(!tableNotExist) {
        state = selectMsgsFromTableDB(streamId, rowsFromDB, merge ? 100 : -1);
//    if (!state) {
//        if (errInfo) {
//            *errInfo = m_db.lastError().text();
//        }
//        return CCBotErrEnums::Sql;
//    }
    }

    // 3. –°–ª–∏—è–Ω–∏–µ
    if(!tableNotExist) {
        mergeMessages(!merge ? rowsFromDB : listRight<MessageData>(rowsFromDB, 100), rowsFromServer, rowsForInsert);
    } else {
        rowsForInsert.append(rowsFromServer);
    }

    // 4. –í—Å—Ç–∞–≤–∫–∞ –Ω–æ–≤—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π –≤ –ë–î
    state = appendMsgIntoTableDB(streamId, rowsForInsert);
//    if(!state) {
//        if (errInfo) {
//            *errInfo = m_db.lastError().text();
//        }
//        return CCBotErrEnums::Sql;
//    }

    // 5. –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —á–∞—Ç–∞
    updateChat(merge ? rowsForInsert : rowsFromDB + rowsForInsert);

    // 6. –ê–Ω–∞–ª–∏–∑ —Å–æ–æ–±—â–µ–Ω–∏–π –Ω–∞ –∫–æ–º–º–∞–Ω–¥—ã -> –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ –∫–æ–º–º–∞–Ω–¥ (–¥–æ–±–∞–≤–ª–µ–Ω–∏–µ –∑–∞–¥–∞—á)
    if(merge) {
        analyseNewMessages(rowsForInsert);
    }

    return CCBotErrEnums::Ok;
}

void CCBot::mergeMessages(QList<MessageData> oldMsgList, QList<MessageData> newMsgList, QList<MessageData> &mergedMsgList)
{
    if (oldMsgList.isEmpty()) {
        mergedMsgList.append(newMsgList);
        return;
    }

    QStringList type3NikNames;

    // –ü–æ–∏—Å–∫ –Ω–∏–∫–æ–≤ –ø–æ–º–µ—á–µ–Ω–Ω—ã—Ö –∫–∞–∫ —Ç–∏–ø 3 –¥–ª—è –∏–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞–Ω–∏—è –≤ —Å—Ä–∞–≤–Ω–µ–Ω–∏–∏ —Å–ø–∏—Å–∫–æ–≤
    foreach (const MessageData &msg, newMsgList) {
        if(msg.type == 3 && !type3NikNames.contains(msg.sender)) {
            type3NikNames.append(msg.sender);
        }
    }

    // –£–¥–∞–ª–µ–Ω–∏–µ –∏–∑ —Å—Ä–∞–≤–Ω–µ–Ω–∏—è —Å–æ–æ–±—â–µ–Ω–∏–π —Å –Ω–∏–∫–æ–º –∏–∑ —Å–ø–∏—Å–∫–∞
    for (const auto &nik : type3NikNames) {
        for (int i = 0; i < oldMsgList.size(); i++) {
            if (oldMsgList.at(i).sender == nik) {
                oldMsgList.removeAt(i--);
            }
        }
        for (int i = 0; i < newMsgList.size(); i++) {
            if (newMsgList.at(i).sender == nik) {
                newMsgList.removeAt(i--);
            }
        }
    }

    // –ü–æ–∏—Å–∫ –∏–Ω—Ç–µ—Ä–≤–∞–ª–æ–≤ –ø–æ—Ö–æ–∂–µ—Å—Ç–∏ –¥–ª—è –≤—ã–±–æ—Ä–∞ –Ω–∞–∏–ª—É—á—à–µ–≥–æ —Å–ª–∏—è–Ω–∏—è —Å–ø–∏—Å–∫–∞ (–≤—ã–±–∏—Ä–∞–µ—Ç—Å—è –∏–Ω—Ç–µ—Ä–≤–∞–ª —Å –±–æ–ª—å—à–∏–º –≤–µ—Å–æ–º - weight)
    QList<MessageData>::const_reverse_iterator iOldMsgs;
    QList<MessageData>::const_reverse_iterator iNewMsgs;
    QList<QPair<int,int> > intervals;
    int start = -1;
    int weight = 0;
    int spaceMsgCount = 0;
    bool flagEnterInterval = false;
    for (iNewMsgs = newMsgList.crbegin(), iOldMsgs = oldMsgList.crbegin(); iNewMsgs != newMsgList.crend() && iOldMsgs != oldMsgList.crend(); ) {
        if (equalMessages(*iNewMsgs, *iOldMsgs)) {
            if (!flagEnterInterval) {
                start = iNewMsgs - newMsgList.crbegin();
                weight = 1;
                flagEnterInterval = true;
            } else {
                weight += 1;
            }
            ++iOldMsgs;
            ++iNewMsgs;
            if (iOldMsgs == oldMsgList.crend()) {
                intervals.append(QPair<int,int>(start, weight));
                break;
            }
            if (iNewMsgs == newMsgList.crend()) {
                intervals.append(QPair<int,int>(start, weight));
                iOldMsgs -= (weight + spaceMsgCount);
            }
        } else {
            if (flagEnterInterval) {
                intervals.append(QPair<int,int>(start, weight));
                flagEnterInterval = false;
                iOldMsgs -= (weight + spaceMsgCount);
                spaceMsgCount = 0;
            }
            ++iNewMsgs;
        }
    }

    // –í—ã–±–æ—Ä –∏–Ω—Ç–µ—Ä–≤–∞–ª–∞
    QPair<int,int> maxInterval = QPair<int,int>(-1, 0);
    for (const auto &interval : intervals) {
        if (interval.second > maxInterval.second) {
            maxInterval = interval;
        }
    }

    // –°–ø–∞–º-–ø–∞–∫–µ—Ç –∏–∑ –ø–∞—á–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏–π —Ç.–∫. –Ω–µ –Ω–∞–π–¥–µ–Ω–æ —Å–æ–≤–ø–∞–¥–µ–Ω–∏–π –≤–æ–æ–±—â–µ! (–µ—Å–ª–∏ —Ç–∞–∫–æ–µ –≤–æ–∑–º–æ–∂–Ω–æ) -> –ø–µ—Ä–µ–¥–∞–µ–º –µ–≥–æ —Å—Ä–∞–∑—É –≤ –∑–∞–ø–∏—Å—å
    if (maxInterval.first == -1) {
        mergedMsgList = newMsgList;
        //qDebug() << "spam!";
        return;
    }

    // –û—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç –Ω–æ–≤—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è!
    if (maxInterval.first == 0) {
        //qDebug() << "empty new";
        return;
    }

    // –ó–∞–ø–∏—Å—ã–≤–∞–µ–º –Ω–æ–≤—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è –≤ —Å–ø–∏—Å–æ–∫ —Å–ª–∏—è–Ω–∏—è
    int startIndex = newMsgList.size() - maxInterval.first;
    //qDebug() << "start_index: " << startIndex;
    mergedMsgList.append(newMsgList.mid(startIndex));
}

bool CCBot::equalMessages(const MessageData &msg1, const MessageData &msg2)
{
    if (msg1.type == msg2.type
            && msg1.sender == msg2.sender
            && qFuzzyCompare(msg1.pay, msg2.pay)
            && msg1.msg == msg2.msg
            ) {
        return true;
    }
    return false;
}

void CCBot::updateChat(const QList<MessageData> &msgsl, bool withTime, QString timeFormat)
{
    for (int i = 0; i < msgsl.size(); i++) {
        MessageData msg = msgsl.value(i);
        QString timeStr = msg.timestamp.toString(timeFormat);
        QString fragment0 = withTime ? timeStr + ": " : "";
        QString nikStr = msg.sender;
        QString fragment1 = nikStr.isEmpty() ? "" : msg.sender + ": ";
        QString fmtFragment1 = msg.nik_color.isEmpty() ? fragment1 : _clr_(fragment1, msg.nik_color);
        QString fragment2 = msg.msg;
        QString fmtFragment2 = fragment2.isEmpty() ?
                    (msg.type == 2 ? _bclr_((QString("($") + QString::number(msg.pay, 'f', 2) + ")"), "#fff200") : "")
                    :
                    (msg.type == 2 ?
                         _bclr_((fragment2 + " ($" + QString::number(msg.pay, 'f', 2) + ")"), "#fff200") :
                         fragment2);
        QString msgStr = fragment0 + fmtFragment1 + fmtFragment2;

        emit showChatMessage(msgStr);
    }
}

void CCBot::analyseNewMessages(const QList<MessageData> &msgsl)
{
    for (int i = 0; i < msgsl.size(); i++) {
        MessageData msg = msgsl.at(i);
        QString text = "";
        //clearUselessSymbols(msg.msg);
        if (checkAutoVoiceMessage(msg, text)) {
            m_pCore->addTask(CCBotTaskEnums::VoiceLoad, text);
        }
    }
}

bool CCBot::checkAutoVoiceMessage(const MessageData &msg, QString &text)
{
    if (msg.msg.isEmpty()) {
        return false;
    }
    if ((m_params->flagAnalyseVoiceAllMsgType2() && msg.type == 2)
            || (m_params->flagAnalyseVoiceAllMsgType0() && msg.type == 0)
            ) {
        QString analyseText = msg.msg;
        // –ø—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –∫–æ–º–º–∞–Ω–¥—É
        if (analyseText.at(0) == QChar('!')) {
            return false;
        }
        // –ø—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –ø—É—Å—Ç–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ
        bool emptyMsg = true;
        for (int i = 0; i < analyseText.length(); i++) {
            if(analyseText.at(i).isLetter()) {
                emptyMsg = false;
                text = analyseText;
                break;
            }
        }
        return !emptyMsg;
    }
    return false;
}

bool CCBot::checkCmdMessage(const MessageData &msg, QString &cmd, QStringList &args)
{
    Q_UNUSED(msg)
    Q_UNUSED(cmd)
    Q_UNUSED(args)
    //
    return false;
}

void CCBot::action(int type, QVariantList args)
{
    switch (type) {
    case CCBotTaskEnums::MergeChat:
        {
            QString streamId = args.value(0,"").toString();
            QString messagesJsonStr = args.value(1,"").toString();
            bool loading = args.value(2, false).toBool();
            m_pCore->addTask(type, streamId, messagesJsonStr, loading);
        }
        break;
    case CCBotTaskEnums::VoiceLoad:
        {
            QString text = args.value(0,"").toString();
            if(!text.isEmpty()) {
                m_pCore->addTask(type, text);
            }
        }
        break;
    case CCBotTaskEnums::OpenBase:
        {
            bool state = openDB();
            emit baseOpenned(state);
        }
        break;
    case CCBotTaskEnums::CloseBase:
        {
            closeDB();
            emit baseOpenned(false);
        }
        break;
    default:
        break;
    }
}

void CCBot::slotFinishedTask(long id, int type, QVariantList argsList, QVariant result)
{
    Q_UNUSED(id)
    Q_UNUSED(argsList)

    auto taskResult = result.value<TaskResult>();
    int errCode = taskResult.errCode();
    QString errInfo = taskResult.errInfo();

    if (errCode != CCBotErrEnums::Ok) {
        emit showMessage(tr("–û—à–∏–±–∫–∞"), generateErrMsg(type, errCode, errInfo), true);
    }
    else
        switch (type) {
        case CCBotTaskEnums::MergeChat:
            {
                bool loading = argsList.value(2, false).toBool();
                if(loading) {
                    m_params->setFlagLoadingChat(false);
                }
            }
            break;
        default:
            break;
        }
}
